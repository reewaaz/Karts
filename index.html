<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Super 2D Kart: GP</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* CRT TV EFFECT CONTAINER */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Retro look */
        }

        /* SCANLINE OVERLAY */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* UI ELEMENTS */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            text-shadow: 4px 4px 0 #000;
        }

        #item-box {
            position: absolute; top: 20px; left: 20px;
            width: 80px; height: 80px;
            border: 4px solid #fff;
            background: rgba(0,0,0,0.5);
            color: #ffeb3b;
            font-size: 40px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 10px;
        }

        #lap-counter {
            position: absolute; top: 20px; right: 20px;
            color: #fff; font-size: 24px;
            text-align: right;
        }
        .small { font-size: 12px; color: #aaa; }

        #center-msg {
            position: absolute; top: 40%; width: 100%;
            text-align: center; font-size: 48px; color: #ffeb3b;
            transform: scale(0); transition: transform 0.2s;
        }
        .pop { transform: scale(1) !important; }

        #controls {
            position: absolute; bottom: 20px; width: 100%;
            text-align: center; font-size: 12px; color: #888;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <div id="item-box">?</div>
        <div id="lap-counter">
            <span id="pos-ui" style="color:#ffcc00; font-size:40px">1st</span><br>
            <span id="lap-ui" class="small">LAP 1/3</span>
        </div>
        <div id="center-msg">GO!</div>
        <div id="controls">WASD / ARROWS to Drive â€¢ SPACE to Drift/Shoot</div>
    </div>
</div>

<script>
/**
 * SUPER 2D KART ENGINE
 * Using Canvas API 2D
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIG ---
const CONFIG = {
    maxSpeed: 12,
    accel: 0.2,
    turnSpeed: 0.07,
    friction: 0.96,
    grassFriction: 0.85,
    laps: 3
};

// --- GAME STATE ---
let gameState = {
    players: [],
    projectiles: [],
    items: [],
    particles: [],
    cam: { x:0, y:0, angle:0 },
    track: null, // The track image data
    lap: 1,
    rank: 1,
    gameActive: true
};

// INPUTS
const keys = { w:0, a:0, s:0, d:0, space:0 };

// --- ASSETS (Procedural Generation) ---
const sprites = {};

function generateSprites() {
    // Helper to draw to temp canvas
    const mkCanvas = (w, h, drawFn) => {
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        drawFn(c.getContext('2d'), w, h);
        return c;
    };

    // 1. KART SPRITE
    sprites.kart = (color) => mkCanvas(40, 40, (c, w, h) => {
        // Shadow
        c.fillStyle = 'rgba(0,0,0,0.5)';
        c.fillRect(5, 5, 30, 30);
        // Wheels
        c.fillStyle = '#222';
        c.fillRect(2, 5, 8, 10); c.fillRect(30, 5, 8, 10); // Front
        c.fillRect(2, 25, 8, 10); c.fillRect(30, 25, 8, 10); // Back
        // Body
        c.fillStyle = color;
        c.beginPath(); c.roundRect(8, 8, 24, 24, 5); c.fill();
        c.fillStyle = '#fff'; // Engine/Seat
        c.fillRect(16, 15, 8, 12);
        // Head
        c.fillStyle = '#ffccaa';
        c.beginPath(); c.arc(20, 20, 6, 0, Math.PI*2); c.fill();
        // Hat
        c.fillStyle = color;
        c.beginPath(); c.arc(20, 18, 6, Math.PI, 0); c.fill();
    });

    // 2. ITEMS
    sprites.shell = (col) => mkCanvas(20, 20, (c) => {
        c.fillStyle = col; c.beginPath(); c.arc(10, 10, 8, 0, Math.PI*2); c.fill();
        c.fillStyle = '#fff'; c.fillRect(8, 6, 4, 4); // Shine
        c.strokeStyle = '#000'; c.lineWidth = 2; c.stroke();
    });

    sprites.banana = mkCanvas(20, 20, (c) => {
        c.fillStyle = '#ffeb3b'; 
        c.beginPath(); c.moveTo(5, 15); c.quadraticCurveTo(10, 5, 15, 15); c.fill();
        c.strokeStyle='#886600'; c.stroke();
    });

    sprites.box = mkCanvas(40, 40, (c) => {
        c.fillStyle = 'rgba(255, 200, 0, 0.8)';
        c.fillRect(0,0,40,40);
        c.strokeStyle = '#fff'; c.lineWidth=4; c.strokeRect(0,0,40,40);
        c.fillStyle = '#fff'; c.font='bold 30px sans-serif'; c.textAlign='center'; c.fillText('?', 20, 30);
    });

    sprites.tree = mkCanvas(60, 60, (c) => {
        c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.arc(35,35,20,0,Math.PI*2); c.fill();
        c.fillStyle = '#228b22'; c.beginPath(); c.arc(30,30,20,0,Math.PI*2); c.fill();
        c.fillStyle = '#3cb371'; c.beginPath(); c.arc(30,30,15,0,Math.PI*2); c.fill();
    });
}

// --- TRACK SYSTEM ---
// We draw the track to a large invisible canvas. 
// We use ctx.getImageData to check collisions (Road vs Grass).
const worldCanvas = document.createElement('canvas');
const worldCtx = worldCanvas.getContext('2d');
const WORLD_SIZE = 3000;
const ROAD_WIDTH = 180; // wide road

const waypoints = []; // For AI

function generateTrack() {
    worldCanvas.width = WORLD_SIZE;
    worldCanvas.height = WORLD_SIZE;

    // 1. Fill Grass
    worldCtx.fillStyle = '#3c9e3c'; // Mario Green
    worldCtx.fillRect(0, 0, WORLD_SIZE, WORLD_SIZE);

    // Decorative Checkerboard grass
    worldCtx.fillStyle = '#4cae4c';
    for(let y=0; y<WORLD_SIZE; y+=100) {
        for(let x=0; x<WORLD_SIZE; x+=100) {
            if((x+y)%200===0) worldCtx.fillRect(x,y,100,100);
        }
    }

    // 2. Define Track Path (x, y)
    const path = [
        {x: 300, y: 300}, {x: 1500, y: 300}, {x: 2500, y: 600},
        {x: 2700, y: 1500}, {x: 2000, y: 2500}, {x: 800, y: 2500},
        {x: 300, y: 1500}, {x: 300, y: 300} // Loop
    ];

    // Smooth Path Logic (Catmull-Rom or Bezier simplified)
    // We just draw thick lines for now with rounded joints
    worldCtx.lineCap = 'round';
    worldCtx.lineJoin = 'round';

    // A. BORDERS (Sand/Offroad)
    worldCtx.lineWidth = ROAD_WIDTH + 40;
    worldCtx.strokeStyle = '#d2b48c'; // Tan
    drawPath(worldCtx, path);

    // B. ROAD (Asphalt)
    worldCtx.lineWidth = ROAD_WIDTH;
    worldCtx.strokeStyle = '#555';
    drawPath(worldCtx, path);

    // C. START LINE
    worldCtx.save();
    worldCtx.translate(300, 300);
    worldCtx.fillStyle = '#fff';
    for(let i=0; i<ROAD_WIDTH; i+=20) {
        if((i/20)%2===0) worldCtx.fillRect(-20, i-ROAD_WIDTH/2, 20, 20); // Checkered line
        else worldCtx.fillStyle='#000'; worldCtx.fillRect(0, i-ROAD_WIDTH/2, 20, 20); worldCtx.fillStyle='#fff';
    }
    worldCtx.restore();

    // D. TREES & DECOR
    for(let i=0; i<50; i++) {
        let tx = Math.random()*WORLD_SIZE;
        let ty = Math.random()*WORLD_SIZE;
        // Don't draw on road (Collision check via pixel reading is expensive here, so we assume random luck or keep simple)
        worldCtx.drawImage(sprites.tree, tx, ty);
    }

    // GENERATE WAYPOINTS (Interpolate path)
    for(let i=0; i<path.length-1; i++) {
        let p1 = path[i];
        let p2 = path[i+1];
        let dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        let steps = dist / 100;
        for(let j=0; j<steps; j++) {
            let t = j/steps;
            waypoints.push({
                x: p1.x + (p2.x - p1.x)*t,
                y: p1.y + (p2.y - p1.y)*t
            });
        }
    }
}

function drawPath(ctx, points) {
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    // Simple interpolation
    for(let i=1; i<points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.stroke();
}

// --- ENTITIES ---

class Kart {
    constructor(x, y, color, isPlayer=false) {
        this.x = x; this.y = y;
        this.color = color;
        this.sprite = sprites.kart(color);
        this.angle = 0;
        this.speed = 0;
        this.isPlayer = isPlayer;
        this.item = null;
        this.wpIndex = 0; // Waypoint index for AI
        this.lap = 1;
        this.checkpoints = 0;
        this.boostTimer = 0;
        this.spinTimer = 0;
        this.width = 30;
    }

    update() {
        if(this.spinTimer > 0) {
            this.spinTimer--;
            this.angle += 0.5;
            this.speed *= 0.9;
            return;
        }

        // 1. PHYSICS
        let max = this.boostTimer > 0 ? CONFIG.maxSpeed * 1.5 : CONFIG.maxSpeed;
        if(this.boostTimer > 0) this.boostTimer--;

        if(this.isPlayer) {
            if(keys.w) this.speed += CONFIG.accel;
            else if(keys.s) this.speed -= CONFIG.accel;
            else this.speed *= CONFIG.friction; // Drag
        } else {
            // AI LOGIC
            let target = waypoints[this.wpIndex];
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let dist = Math.hypot(dx, dy);
            let targetAngle = Math.atan2(dy, dx);
            
            // Turn towards target
            let diff = targetAngle - this.angle;
            // Normalize angle
            while(diff < -Math.PI) diff += Math.PI*2;
            while(diff > Math.PI) diff -= Math.PI*2;
            
            this.angle += Math.sign(diff) * Math.min(Math.abs(diff), CONFIG.turnSpeed);
            this.speed += CONFIG.accel; // Always gas

            if(dist < 100) {
                this.wpIndex = (this.wpIndex + 1) % waypoints.length;
                // Lap Count check for AI (Roughly based on waypoints loop)
                if(this.wpIndex === 0) this.lap++;
            }
        }

        // Cap Speed
        this.speed = Math.min(Math.max(this.speed, -4), max);

        // Turn
        if(this.isPlayer && Math.abs(this.speed) > 0.5) {
            if(keys.a) this.angle -= CONFIG.turnSpeed;
            if(keys.d) this.angle += CONFIG.turnSpeed;
        }

        // Velocity Vector
        let vx = Math.cos(this.angle) * this.speed;
        let vy = Math.sin(this.angle) * this.speed;

        // 2. COLLISION (ROAD CHECK)
        // We read the pixel under the kart center
        // To save performance, we only read every few frames or map coordinates
        // Here we assume integer positions
        try {
            let pixel = worldCtx.getImageData(Math.floor(this.x), Math.floor(this.y), 1, 1).data;
            // Road is Grey (R=85, G=85, B=85) or Start line White
            // Grass is Green (R~60, G~158)
            // If Green channel is high and Red/Blue low, it's grass
            if(pixel[1] > 100 && pixel[0] < 100) {
                // On Grass -> Slow Down
                this.speed *= CONFIG.grassFriction;
                // Add dust particle
                if(Math.random()>0.5 && Math.abs(this.speed)>2) addParticle(this.x, this.y, '#fff');
            }
        } catch(e) {}

        this.x += vx;
        this.y += vy;

        // 3. LAP CHECK (Player)
        if(this.isPlayer) {
            // Distance to start line (300, 300)
            let distToStart = Math.hypot(this.x - 300, this.y - 300);
            if(distToStart < 200 && this.checkpoints > 100) {
                this.lap++;
                this.checkpoints = 0;
                document.getElementById('lap-ui').innerText = `LAP ${this.lap}/${CONFIG.laps}`;
                showMsg(`LAP ${this.lap}!`);
                if(this.lap > CONFIG.laps) endGame();
            }
            this.checkpoints++;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2); // Sprite faces up, engine uses 0 rad = right
        ctx.drawImage(this.sprite, -20, -20);
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, type) {
        this.x = x; this.y = y; this.angle = angle;
        this.type = type;
        this.speed = type === 'shell' ? 15 : 0;
        this.life = 300;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        
        // Bounce logic (Simple bounds)
        if(this.x < 0 || this.x > WORLD_SIZE) this.angle = Math.PI - this.angle;
        if(this.y < 0 || this.y > WORLD_SIZE) this.angle = -this.angle;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        if(this.type === 'shell') ctx.drawImage(sprites.shell('#0f0'), -10, -10);
        else ctx.drawImage(sprites.banana, -10, -10);
        ctx.restore();
    }
}

// --- MAIN LOOP ---

function init() {
    generateSprites();
    generateTrack();

    // Create Player
    gameState.players.push(new Kart(300, 320, '#ff0000', true)); // Mario
    // Create CPU
    gameState.players.push(new Kart(300, 280, '#00ff00')); // Luigi
    gameState.players.push(new Kart(260, 300, '#ff69b4')); // Peach
    gameState.players.push(new Kart(260, 340, '#ffff00')); // Wario

    // Item Boxes
    for(let i=0; i<8; i++) {
        let wp = waypoints[Math.floor(i * (waypoints.length/8))];
        gameState.items.push({x: wp.x, y: wp.y, active: true});
    }

    // Input Handlers
    window.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        if(k==='w'||k==='arrowup') keys.w = 1;
        if(k==='s'||k==='arrowdown') keys.s = 1;
        if(k==='a'||k==='arrowleft') keys.a = 1;
        if(k==='d'||k==='arrowright') keys.d = 1;
        if(k===' ') {
            if(!keys.space) useItem();
            keys.space = 1;
        }
    });
    window.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        if(k==='w'||k==='arrowup') keys.w = 0;
        if(k==='s'||k==='arrowdown') keys.s = 0;
        if(k==='a'||k==='arrowleft') keys.a = 0;
        if(k==='d'||k==='arrowright') keys.d = 0;
        if(k===' ') keys.space = 0;
    });
    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(loop);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function useItem() {
    const p = gameState.players[0];
    if(!p.item) return;

    if(p.item === 'mushroom') {
        p.boostTimer = 60;
        showMsg("BOOST!");
    } else if (p.item === 'shell') {
        gameState.projectiles.push(new Projectile(p.x, p.y, p.angle, 'shell'));
    } else if (p.item === 'banana') {
        gameState.projectiles.push(new Projectile(p.x, p.y, p.angle, 'banana'));
    }

    p.item = null;
    document.getElementById('item-box').innerText = "";
}

function showMsg(txt) {
    const el = document.getElementById('center-msg');
    el.innerText = txt;
    el.classList.add('pop');
    setTimeout(() => el.classList.remove('pop'), 1000);
}

function addParticle(x, y, color) {
    gameState.particles.push({x, y, life: 20, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, color});
}

function loop() {
    if(!gameState.gameActive) return;

    // 1. UPDATE
    const p1 = gameState.players[0];
    
    // Update All Karts
    gameState.players.forEach(p => p.update());
    
    // Camera Follows P1
    gameState.cam.x = p1.x;
    gameState.cam.y = p1.y;
    // Camera Rotate (Optional: Rotate world around car angle for dynamic feel)
    // To make it easier to drive, let's keep North Up or Car Up?
    // Let's do Car Up (Mode 7 style feel)
    gameState.cam.angle = -p1.angle - Math.PI/2;

    // Projectiles
    gameState.projectiles.forEach((p, i) => {
        p.update();
        if(p.life<=0) gameState.projectiles.splice(i,1);
        // Collision with karts
        gameState.players.forEach(kart => {
            if(Math.hypot(kart.x-p.x, kart.y-p.y) < 20 && p.life < 290) { // 290 prevents self hit instantly
                kart.spinTimer = 60;
                p.life = 0;
            }
        });
    });

    // Item Pickup
    gameState.items.forEach(it => {
        if(!it.active) return;
        if(Math.hypot(p1.x - it.x, p1.y - it.y) < 30) {
            it.active = false;
            setTimeout(()=>it.active=true, 3000);
            // Give Item
            const loot = ['mushroom', 'shell', 'banana'];
            p1.item = loot[Math.floor(Math.random()*loot.length)];
            
            // Roulette UI
            let count = 0;
            let inter = setInterval(() => {
                document.getElementById('item-box').innerText = ['?','ðŸ„','ðŸ¢','ðŸŒ'][count%4];
                count++;
                if(count>10) {
                    clearInterval(inter);
                    const icon = p1.item==='mushroom'?'ðŸ„':(p1.item==='shell'?'ðŸ¢':'ðŸŒ');
                    document.getElementById('item-box').innerText = icon;
                }
            }, 50);
        }
    });

    // Rank Calc
    let r = 1;
    gameState.players.forEach(p => {
        if(!p.isPlayer && (p.lap > p1.lap || (p.lap===p1.lap && p.wpIndex > p1.wpIndex))) r++;
    });
    document.getElementById('pos-ui').innerText = r + (r==1?'st':r==2?'nd':r==3?'rd':'th');

    // 2. DRAW
    // Clear screen
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    ctx.save();
    
    // Move to Center of Screen
    ctx.translate(canvas.width/2, canvas.height/2);
    // Rotate World
    ctx.rotate(gameState.cam.angle);
    // Move to Player Position
    ctx.translate(-gameState.cam.x, -gameState.cam.y);

    // A. DRAW TRACK (Optimized: Draw the cached canvas)
    // We only draw a sub-region for performance if the world is huge, but 3000px is fine for desktop
    ctx.drawImage(worldCanvas, 0, 0);

    // B. DRAW ITEMS
    gameState.items.forEach(it => {
        if(it.active) ctx.drawImage(sprites.box, it.x-20, it.y-20);
    });

    // C. DRAW PARTICLES
    gameState.particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life--;
        ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4);
        if(p.life<=0) gameState.particles.splice(i,1);
    });

    // D. DRAW PROJECTILES
    gameState.projectiles.forEach(p => p.draw(ctx));

    // E. DRAW PLAYERS
    gameState.players.forEach(p => p.draw(ctx));

    ctx.restore();

    requestAnimationFrame(loop);
}

function endGame() {
    showMsg("FINISH!");
    gameState.gameActive = false;
}

init();

</script>
</body>
</html>
